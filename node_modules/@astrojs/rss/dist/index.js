import { XMLBuilder, XMLParser } from "fast-xml-parser";
import { createCanonicalURL, isValidURL } from "./util.js";
function isGlobResult(items) {
  return typeof items === "object" && !items.length;
}
function mapGlobResult(items) {
  return Promise.all(
    Object.values(items).map(async (getInfo) => {
      const { url, frontmatter } = await getInfo();
      if (url === void 0 || url === null) {
        throw new Error(
          `[RSS] When passing an import.meta.glob result directly, you can only glob ".md" (or alternative extensions for markdown files like ".markdown") files within /pages! Consider mapping the result to an array of RSSFeedItems. See the RSS docs for usage examples: https://docs.astro.build/en/guides/rss/#2-list-of-rss-feed-objects`
        );
      }
      if (!Boolean(frontmatter.title) || !Boolean(frontmatter.pubDate)) {
        throw new Error(`[RSS] "${url}" is missing a "title" and/or "pubDate" in its frontmatter.`);
      }
      return {
        link: url,
        title: frontmatter.title,
        pubDate: frontmatter.pubDate,
        description: frontmatter.description,
        customData: frontmatter.customData
      };
    })
  );
}
async function getRSS(rssOptions) {
  const { site } = rssOptions;
  let { items } = rssOptions;
  if (!site) {
    throw new Error('[RSS] the "site" option is required, but no value was given.');
  }
  if (isGlobResult(items)) {
    items = await mapGlobResult(items);
  }
  return {
    body: await generateRSS({
      rssOptions,
      items
    })
  };
}
async function generateRSS({ rssOptions, items }) {
  var _a;
  const { site } = rssOptions;
  const xmlOptions = { ignoreAttributes: false };
  const parser = new XMLParser(xmlOptions);
  const root = { "?xml": { "@_version": "1.0", "@_encoding": "UTF-8" } };
  if (typeof rssOptions.stylesheet === "string") {
    const isXSL = /\.xsl$/i.test(rssOptions.stylesheet);
    root["?xml-stylesheet"] = {
      "@_href": rssOptions.stylesheet,
      ...isXSL && { "@_type": "text/xsl" }
    };
  }
  root.rss = { "@_version": "2.0" };
  if (items.find((result) => result.content)) {
    const XMLContentNamespace = "http://purl.org/rss/1.0/modules/content/";
    root.rss["@_xmlns:content"] = XMLContentNamespace;
    if (((_a = rssOptions.xmlns) == null ? void 0 : _a.content) && rssOptions.xmlns.content === XMLContentNamespace) {
      delete rssOptions.xmlns.content;
    }
  }
  if (rssOptions.xmlns) {
    for (const [k, v] of Object.entries(rssOptions.xmlns)) {
      root.rss[`@_xmlns:${k}`] = v;
    }
  }
  root.rss.channel = {
    title: rssOptions.title,
    description: rssOptions.description,
    link: createCanonicalURL(site).href
  };
  if (typeof rssOptions.customData === "string")
    Object.assign(
      root.rss.channel,
      parser.parse(`<channel>${rssOptions.customData}</channel>`).channel
    );
  root.rss.channel.item = items.map((result) => {
    validate(result);
    const itemLink = isValidURL(result.link) ? result.link : createCanonicalURL(result.link, site).href;
    const item = {
      title: result.title,
      link: itemLink,
      guid: itemLink
    };
    if (result.description) {
      item.description = result.description;
    }
    if (result.pubDate) {
      if (typeof result.pubDate === "number" || typeof result.pubDate === "string") {
        result.pubDate = new Date(result.pubDate);
      } else if (result.pubDate instanceof Date === false) {
        throw new Error("[${filename}] rss.item().pubDate must be a Date");
      }
      item.pubDate = result.pubDate.toUTCString();
    }
    if (typeof result.content === "string") {
      item["content:encoded"] = result.content;
    }
    if (typeof result.customData === "string") {
      Object.assign(item, parser.parse(`<item>${result.customData}</item>`).item);
    }
    return item;
  });
  return new XMLBuilder(xmlOptions).build(root);
}
const requiredFields = Object.freeze(["link", "title"]);
function validate(item) {
  for (const field of requiredFields) {
    if (!(field in item)) {
      throw new Error(
        `@astrojs/rss: Required field [${field}] is missing. RSS cannot be generated without it.`
      );
    }
  }
}
export {
  getRSS as default,
  generateRSS
};
